@startuml STDS Decision Making Sequence Diagram

title Real-time Decision Making - STDS Framework

actor Trader
participant "React UI" as UI
participant "Socket.io\nClient" as SocketClient
participant "Socket.io\nServer" as SocketServer
participant "N-API\nBindings" as NAPI
participant "STDSEngine" as Engine
participant "Normalizer" as Normalizer
participant "SequenceTree" as Tree
participant "D3.js\nVisualization" as D3
participant "Lightweight\nCharts" as Charts

== New Market Data Processing ==

Trader -> UI: Input new OHLCV data
activate UI
note right of UI
  Manual input or
  live data stream
end note

UI -> UI: Validate input
UI -> SocketClient: emit('processData', ohlcv)
activate SocketClient
SocketClient -> SocketServer: WebSocket: processData
activate SocketServer
SocketServer -> NAPI: engine.processNewData(ohlcv)
activate NAPI
NAPI -> Engine: processNewData(data)
activate Engine

Engine -> Engine: Add to historical_data
Engine -> Normalizer: calculateLogReturn(prev, curr)
activate Normalizer
Normalizer -> Normalizer: ln(curr_close / prev_close)
Normalizer --> Engine: log_return
deactivate Normalizer

Engine -> Normalizer: transform(log_return)
activate Normalizer
Normalizer -> Normalizer: Find appropriate bin
Normalizer --> Engine: symbol
deactivate Normalizer

Engine -> Engine: Update symbol_sequence
Engine -> Engine: Keep last sequence_length symbols

alt Sequence length reached
  Engine -> Tree: query(symbol_sequence)
  activate Tree
  Tree -> Tree: Traverse tree following sequence
  
  alt Sequence found in tree
    Tree -> Tree: Get node synthesis
    Tree --> Engine: Decision (BUY/SELL/HOLD/NONE)
  else Sequence not found
    Tree --> Engine: "NONE"
  end
  deactivate Tree
else Sequence too short
  Engine --> Engine: "NONE"
end

Engine --> NAPI: decision
deactivate Engine
NAPI --> SocketServer: decision string
deactivate NAPI

SocketServer -> SocketClient: emit('DECISION_TRIGGERED', {decision, data, timestamp})
deactivate SocketServer
activate SocketClient

SocketClient -> UI: Update decision state
activate UI

par Parallel Visualization Updates
  UI -> D3: Highlight active path
  activate D3
  D3 -> D3: Find nodes in sequence
  D3 -> D3: Apply highlight style
  D3 --> UI: Path highlighted
  deactivate D3
  
  UI -> Charts: Add candlestick + marker
  activate Charts
  Charts -> Charts: Add OHLCV candle
  
  alt Decision is BUY
    Charts -> Charts: Add green arrow up marker
  else Decision is SELL
    Charts -> Charts: Add red arrow down marker
  else Decision is HOLD
    Charts -> Charts: Add yellow circle marker
  end
  
  Charts --> UI: Chart updated
  deactivate Charts
end

UI -> UI: Add to decision history
UI --> Trader: Display decision + visualization
deactivate UI
deactivate SocketClient

== Performance Metrics ==

note over Engine, Tree
  Query Performance:
  - Time Complexity: O(sequence_length)
  - Measured Latency: 0ms
  - Specification: < 10ms âœ“
end note

note over SocketServer, SocketClient
  Real-time Communication:
  - WebSocket for low latency
  - Event-driven architecture
  - Bi-directional updates
end note

note over D3, Charts
  Visualization Updates:
  - D3.js: Tree structure with path highlighting
  - Lightweight Charts: Candlestick + decision markers
  - Real-time rendering without page reload
end note

@enduml
